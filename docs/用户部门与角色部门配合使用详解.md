# user_admin_setting.dept_id 与 role_belongs_department 配合使用详解

## 权限判断流程

```
用户请求数据 → 获取正常状态角色 → applyUserDataScope() → 根据 data_scope 选择数据源 → 获取用户ID列表 → whereIn('created_by', $userIds) → 返回过滤后的数据
```

**核心原理**：
- 数据最终归属为 `created_by` 字段（数据创建者）
- 先根据权限范围获取可访问的用户ID列表，再通过 `whereIn('created_by', $userIds)` 过滤数据

## 权限类型与数据源

| 权限类型 | data_scope | 数据源 | 说明 |
|---------|-----------|--------|------|
| 全部权限 | 1 | 无 | 不添加过滤条件 |
| 自定义权限 | 2 | `role_belongs_department` | 角色可访问的部门数据权限 |
| 本部门权限 | 3 | `user_admin_setting.dept_id` | 用户所属的部门 |
| 本部门及以下 | 4 | `user_admin_setting.dept_id` | 用户所属的部门及其子部门 |
| 本人权限 | 5 | 无 | 当前用户ID |

**权限优先级**（从高到低）：1 > 2 > 4 > 3 > 5

**多角色处理**：按优先级取最高权限，自定义权限会合并所有自定义角色的部门ID（去重）

## 核心方法

### applyUserDataScope()

根据当前用户的数据权限范围，对查询构建器添加过滤条件。

**处理流程**：
1. 获取当前用户（带缓存）
2. 检查是否为超级管理员
3. 获取用户的所有正常状态角色
4. 按优先级判断权限类型并添加过滤条件

### getUserIdsByDeptIds()

根据部门ID列表，查询属于这些部门的用户ID列表。

**实现方式**：查询 `user_admin_setting` 表，`dept_id` 是 JSON 数组字段，使用 `whereJsonContains` 查询

## 权限类型使用场景

### 自定义数据权限（data_scope=2）

**流程**：角色可访问的部门 → 查询这些部门下的用户 → 过滤数据

```php
// 角色配置：可访问部门 [1, 2, 3]
$role->departments()->attach([1, 2, 3]);

// 查询逻辑
// 1. 从 role_belongs_department 获取部门ID：[1, 2, 3]
// 2. getUserIdsByDeptIds([1, 2, 3]) → [101, 102, 103, 104]
// 3. whereIn('created_by', [101, 102, 103, 104])
// 结果：可访问所有由属于这些部门的用户创建的数据
```

### 本部门数据权限（data_scope=3）

**流程**：用户所属部门 → 查询同部门下的用户 → 过滤数据

```php
// 用户配置：属于销售部
$user->adminSetting->dept_id = [2];

// 查询逻辑
// 1. getUserDeptIds($user) → [2]
// 2. getUserIdsByDeptIds([2]) → [201, 202]
// 3. whereIn('created_by', [201, 202])
// 结果：只能访问所有由销售部用户创建的数据
```

### 本部门及以下数据权限（data_scope=4）

**流程**：用户所属部门及其子部门 → 查询这些部门下的用户 → 过滤数据

```php
// 用户配置：属于技术部
$user->adminSetting->dept_id = [1];

// 部门结构：技术部(id=1) → 前端组(id=4)、后端组(id=5)

// 查询逻辑
// 1. getUserDeptIds($user) → [1]
// 2. getAllChildrenIds(1) → [1, 4, 5]
// 3. getUserIdsByDeptIds([1, 4, 5]) → [301, 302, 303, 304]
// 4. whereIn('created_by', [301, 302, 303, 304])
// 结果：可访问技术部及其子部门的所有用户创建的数据
```

### 本人数据权限（data_scope=5）

**流程**：直接使用当前用户ID过滤

```php
// 查询逻辑
where('created_by', $user->id)
// 结果：只能访问自己创建的数据
```

## 多角色权限策略

当用户拥有多个角色时，按优先级取最高权限：

```php
// 用户拥有两个角色
$roles = [
    ['id' => 1, 'data_scope' => 2],  // 项目管理员（自定义权限）
    ['id' => 2, 'data_scope' => 3],  // 销售员（本部门权限）
];

// 处理逻辑：按优先级取最高权限（data_scope=2）
// 1. 检查是否有全部权限（data_scope=1）→ 无
// 2. 检查是否有自定义权限（data_scope=2）→ 有，使用此权限
// 3. 批量查询 role_belongs_department 获取部门ID：[1, 2]
```

**注意事项**：
- 多个自定义权限角色的部门ID会被合并去重
- 优先级高的权限类型会覆盖优先级低的权限类型
- 系统不会取权限的并集，而是取最高权限

## 配合关系总结

| 数据源 | 作用 | 使用时机 | 数据类型 |
|--------|------|---------|---------|
| `role_belongs_department` | 定义角色可访问的部门数据权限 | data_scope=2（自定义权限） | 关联表 |
| `user_admin_setting.dept_id` | 定义用户所属的部门 | data_scope=3、4（本部门权限） | JSON数组 |
| `created_by` | 数据的最终归属字段 | 所有权限类型的最终过滤 | 整数 |

## 配合逻辑

| data_scope | 使用的数据源 | 查询用户ID | 最终过滤 |
|-----------|------------|-----------|---------|
| 1 (全部) | 无 | 无 | 无过滤条件 |
| 2 (自定义) | `role_belongs_department` | 根据角色部门查询用户ID | `whereIn('created_by', $userIds)` |
| 3 (本部门) | `user_admin_setting.dept_id` | 根据用户部门查询用户ID | `whereIn('created_by', $userIds)` |
| 4 (本部门及以下) | `user_admin_setting.dept_id` | 根据用户部门+子部门查询用户ID | `whereIn('created_by', $userIds)` |
| 5 (本人) | 无 | 当前用户ID | `where('created_by', $user->id)` |

## 关键点

1. ✅ **数据归属明确**：所有数据最终归属为 `created_by` 字段，权限过滤基于数据创建者
2. ✅ **两者互补**：角色部门用于权限配置，用户部门用于组织架构
3. ✅ **两阶段查询**：先根据部门查询用户ID，再根据用户ID过滤数据
4. ✅ **性能优化**：使用批量查询避免N+1问题，使用缓存机制减少数据库查询

## 性能优化

**优化前**：循环查询每个角色的部门（N+1查询问题）

**优化后**：批量查询所有自定义角色的部门（1次查询）

```php
// 批量查询所有自定义角色的部门
$customRoleIds = $roles->where('data_scope', DataScopeTool::DATA_SCOPE_CUSTOM)->pluck('id')->toArray();
$roleDeptIds = Db::table('role_belongs_department')
    ->whereIn('role_id', $customRoleIds)
    ->pluck('dept_id')
    ->toArray();
```

## 注意事项

1. **缓存更新**：用户角色或部门变更后，调用 `DataScopeTool::clearCurrentUserCache($userId)` 清除缓存
2. **角色状态**：只有正常状态（status=1）的角色才会参与权限判断
3. **部门不存在**：如果用户没有部门，会返回空结果
4. **超级管理员**：拥有 `SuperAdmin` 角色的用户拥有全部数据权限

## 使用示例

```php
// 在Repository中使用
public function handleSearch(Builder $query, array $params): Builder
{
    DataScopeTool::applyUserDataScope(0, $query); // 0 表示使用当前登录用户
    return $query;
}

// 更新用户信息后清除缓存
DataScopeTool::clearCurrentUserCache($userId);
```

