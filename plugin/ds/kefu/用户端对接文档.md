# 客服插件用户端对接文档

## 目录
1. [概述](#概述)
2. [快速开始](#快速开始)
3. [HTTP API接口](#http-api接口)
4. [WebSocket接口](#websocket接口)
5. [消息推送机制](#消息推送机制)
6. [游客对接](#游客对接)
7. [完整集成示例](#完整集成示例)
8. [注意事项](#注意事项)

---

## 概述

客服插件（ds/kefu）提供完整的客服功能，用户端需要对接以下内容：

- **HTTP API**：获取会话、获取消息列表
- **WebSocket**：发送消息、标记已读、结束会话
- **消息推送**：接收客服发送的消息和会话状态变化通知

### 核心功能

- ✅ 自动分配客服会话
- ✅ 实时消息收发（WebSocket）
- ✅ 消息推送（`KefuMessageListener` 自动推送）
- ✅ 支持文本、图片、文件消息
- ✅ 消息已读状态管理
- ✅ 会话结束通知

---

## 快速开始

### 1. 前置条件

- 用户已登录，拥有有效的用户Token
- WebSocket服务已启动并可访问

### 2. 基本流程

```
1. 用户登录 → 获取用户Token
2. 建立WebSocket连接 → 使用Token登录
3. 获取或创建会话 → 调用 getConversation API
4. 发送消息 → 通过WebSocket发送消息
5. 接收消息 → 监听WebSocket推送
6. 标记已读 → 通过WebSocket标记消息已读
```

---

## HTTP API接口

所有用户端API都需要在请求头中携带用户Token：

```
Authorization: Bearer {user_token}
```

### 1. 获取或创建会话

**接口地址**：`GET /api/kefu/message/getConversation`

**功能说明**：
- 如果用户已有进行中的会话（status=1），返回该会话
- 如果没有，自动创建新会话并分配给当前并发数最少的客服
- 会话分配策略：按 `current_concurrent` 升序排序，选择第一个可用的客服

**请求示例**：
```javascript
const response = await fetch('/api/kefu/message/getConversation', {
  headers: {
    'Authorization': 'Bearer your_user_token'
  }
});
const result = await response.json();
```

**响应示例**：
```json
{
  "code": 200,
  "data": {
    "id": 1,
    "kefu_id": 1,
    "user_id": 100,
    "status": 1,
    "last_message_at": null,
    "unread_count": 0,
    "kefu_unread_count": 0,
    "created_at": "2025-01-01 10:00:00",
    "updated_at": "2025-01-01 10:00:00"
  }
}
```

**字段说明**：
- `id`: 会话ID，后续操作都需要使用
- `kefu_id`: 分配的客服ID
- `user_id`: 用户ID
- `status`: 会话状态，1-进行中，2-已结束
- `unread_count`: 用户侧未读消息数（客服发送的消息）
- `kefu_unread_count`: 客服侧未读消息数（用户发送的消息）

### 2. 获取消息列表

**接口地址**：`GET /api/kefu/message/list`

**请求参数**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| conversation_id | int | 是 | 会话ID |
| page | int | 否 | 页码，默认1 |
| page_size | int | 否 | 每页数量，默认10 |

**请求示例**：
```javascript
const conversationId = 1;
const page = 1;
const pageSize = 20;

const response = await fetch(
  `/api/kefu/message/list?conversation_id=${conversationId}&page=${page}&page_size=${pageSize}`,
  {
    headers: {
      'Authorization': 'Bearer your_user_token'
    }
  }
);
const result = await response.json();
```

**响应示例**：
```json
{
  "code": 200,
  "data": [
    {
      "id": 1,
      "conversation_id": 1,
      "sender_id": 100,
      "sender_type": 1,
      "content": "你好",
      "message_type": 1,
      "file_url": null,
      "is_read": 0,
      "read_at": null,
      "created_at": "2025-01-01 10:00:00",
      "updated_at": "2025-01-01 10:00:00"
    },
    {
      "id": 2,
      "conversation_id": 1,
      "sender_id": 1,
      "sender_type": 2,
      "content": "您好，有什么可以帮您的吗？",
      "message_type": 1,
      "file_url": null,
      "is_read": 1,
      "read_at": "2025-01-01 10:05:00",
      "created_at": "2025-01-01 10:02:00",
      "updated_at": "2025-01-01 10:05:00"
    }
  ]
}
```

**字段说明**：
- `id`: 消息ID
- `conversation_id`: 会话ID
- `sender_id`: 发送者ID
- `sender_type`: 发送者类型，1-用户，2-客服
- `content`: 消息内容
- `message_type`: 消息类型，1-文本，2-图片，3-文件
- `file_url`: 文件URL（图片或文件类型时使用）
- `is_read`: 是否已读，0-未读，1-已读
- `read_at`: 阅读时间

**注意**：返回的消息列表是按时间倒序排列的，最新的消息在最后。

---

## WebSocket接口

### 连接要求

1. **建立WebSocket连接**：
   ```javascript
   const ws = new WebSocket('ws://your-domain/ws');
   ```

2. **登录认证**（连接后立即发送）：
   ```javascript
   ws.onopen = () => {
     ws.send(JSON.stringify({
       action: 'login',
       data: {
         token: 'your_user_token'
       }
     }));
   };
   ```

### WebSocket消息格式

所有WebSocket消息统一格式：
```json
{
  "action": "动作名称",
  "data": {
    // 具体数据
  },
  "op_id": "操作ID（可选，原样返回）"
}
```

### 支持的Action

#### 1. 发送消息

**Action**: `kefu_message_send`

**请求格式**：
```json
{
  "action": "kefu_message_send",
  "data": {
    "conversation_id": 1,
    "content": "你好",
    "message_type": 1,
    "file_url": null
  },
  "op_id": "unique_op_id"
}
```

**注意**：用户端无需传入 `sender_type`，系统会自动设置为 `1`（用户）。**仅管理端需要传入 `sender_type = 2`（客服）**。

**参数说明**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| conversation_id | int | 是 | 会话ID |
| content | string | 条件 | 消息内容（文本消息必填，图片/文件可选） |
| message_type | int | 否 | 消息类型：1-文本，2-图片，3-文件，默认1 |
| file_url | string | 条件 | 文件URL（图片或文件类型时必填） |
| sender_type | int | 否 | 发送者类型：**仅管理端需要传入 `2`（客服），用户端无需传入，系统自动设置为 `1`（用户）** |

**响应示例**：
```json
{
  "success": true,
  "message": "Message sent successfully",
  "data": {
    "message_id": 123,
    "created_at": "2025-01-01 10:00:00"
  },
  "op_id": "unique_op_id"
}
```

**错误响应**：
```json
{
  "success": false,
  "message": "conversation_id is required",
  "op_id": "unique_op_id"
}
```

**消息类型说明**：
- `message_type = 1`（文本消息）：`content` 必填，`file_url` 可选
- `message_type = 2`（图片消息）：`file_url` 必填，`content` 可选（可作为图片描述）
- `message_type = 3`（文件消息）：`file_url` 必填，`content` 可选（可作为文件描述）

**发送者类型说明**：
- `sender_type = 1`（用户发送）：**用户端默认值**，用户端无需传入，系统自动设置为 `1`
- `sender_type = 2`（客服发送）：**仅管理端需要传入**，表示消息由客服发送（管理端代客服发送消息时使用）
- **重要**：用户端发送消息时，**不要传入 `sender_type` 参数**，系统会自动设置为 `1`（用户）

#### 2. 标记消息已读

**Action**: `kefu_message_read`

**请求格式**：
```json
{
  "action": "kefu_message_read",
  "data": {
    "conversation_id": 1,
    "message_ids": [1, 2, 3],
    "sender_type": 2
  },
  "op_id": "unique_op_id"
}
```

**参数说明**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| conversation_id | int | 是 | 会话ID |
| message_ids | array | 是 | 消息ID数组 |
| sender_type | int | 是 | 要标记的消息的发送者类型 |

**sender_type 说明**：
- `sender_type = 1`: 标记用户发送的消息为已读（客服调用）
- `sender_type = 2`: 标记客服发送的消息为已读（**用户调用**）

**响应示例**：
```json
{
  "success": true,
  "message": "Messages marked as read",
  "data": {
    "updated_count": 3
  },
  "op_id": "unique_op_id"
}
```

#### 3. 结束会话

**Action**: `kefu_message_end`

**请求格式**：
```json
{
  "action": "kefu_message_end",
  "data": {
    "conversation_id": 1
  },
  "op_id": "unique_op_id"
}
```

**参数说明**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| conversation_id | int | 是 | 会话ID |

**权限说明**：
- 用户只能结束自己的会话（验证 `conversation.user_id == userId`）

**响应示例**：
```json
{
  "success": true,
  "message": "Conversation ended successfully",
  "data": {
    "conversation_id": 1
  },
  "op_id": "unique_op_id"
}
```

**错误响应**：
```json
{
  "success": false,
  "message": "Failed to end conversation. Conversation not found or no permission.",
  "op_id": "unique_op_id"
}
```

**功能说明**：
- 结束会话后，会话状态更新为 `2`（已结束）
- 如果会话是进行中状态，会自动减少客服的 `current_concurrent` 计数
- 如果会话已经是结束状态，直接返回成功
- 使用数据库事务确保数据一致性

---

## 消息推送机制

### 推送流程说明

消息推送由 `KefuMessageListener` 自动处理，无需用户端额外配置：

1. **消息保存**：通过 `KefuMessageService::save()` 保存消息到数据库
2. **触发事件**：保存成功后触发 `MessageSendEvent` 或 `MessageEndEvent` 事件
3. **监听处理**：`KefuMessageListener` 统一监听事件并处理推送
4. **推送目标**：使用 `from_uid` 和 `to_uid` 字段来确定推送目标
   - `from_uid`: 发送者UID（用于标识消息来源）
   - `to_uid`: 接收者UID（单个或数组，用于获取WebSocket连接）

### 推送消息格式

当客服发送消息时，用户端会收到以下格式的推送消息：

```json
{
  "type": "push_message",
  "action": "kefu_message",
  "conversation_id": 1,
  "message_id": 123,
  "sender_id": 1,
  "sender_type": 2,
  "from_uid": 1,
  "to_uid": 100,
  "content": "您好，有什么可以帮您的吗？",
  "message_type": 1,
  "file_url": null,
  "created_at": "2025-01-01 10:00:00",
  "timestamp": 1704067200
}
```

**字段说明**：
- `type`: 固定为 `"push_message"`，用于标识这是推送消息
- `action`: 固定为 `"kefu_message"`，用于标识这是客服消息推送
- `conversation_id`: 会话ID
- `message_id`: 消息ID
- `sender_id`: 发送者ID（与 `from_uid` 相同）
- `sender_type`: 发送者类型，1-用户，2-客服
- `from_uid`: 发送者UID（用于推送路由）
- `to_uid`: 接收者UID（用于推送路由）
- `content`: 消息内容
- `message_type`: 消息类型，1-文本，2-图片，3-文件
- `file_url`: 文件URL（图片或文件类型时使用）
- `created_at`: 创建时间
- `timestamp`: Unix时间戳（秒）

**推送逻辑**：
- 用户发送消息（`sender_type=1`）：`from_uid = user_id`, `to_uid = kefu_id`，推送给客服
- 客服发送消息（`sender_type=2`）：`from_uid = kefu_id`, `to_uid = user_id`，推送给用户

### 会话结束推送

当会话被结束时（用户或客服操作），会推送会话结束通知：

```json
{
  "type": "push_message",
  "action": "kefu_message_end",
  "conversation_id": 1,
  "operator_id": 100,
  "operator_type": 1,
  "from_uid": 100,
  "to_uid": [100, 1],
  "timestamp": 1704067200
}
```

**字段说明**：
- `type`: 固定为 `"push_message"`，用于标识这是推送消息
- `action`: 固定为 `"kefu_message_end"`，用于标识这是会话结束推送
- `conversation_id`: 会话ID
- `operator_id`: 操作者ID（与 `from_uid` 相同）
- `operator_type`: 操作者类型，1-用户，2-客服/管理员
- `from_uid`: 操作者UID（发送者）
- `to_uid`: 接收者UID数组（推送给用户和客服双方）
- `timestamp`: Unix时间戳（秒）

**推送逻辑**：
- 会话结束通知会推送给用户和客服双方（`to_uid` 为数组 `[user_id, kefu_id]`）
- `from_uid` 标识是谁发起的结束操作

### 接收推送消息示例

```javascript
ws.onmessage = (event) => {
  const message = JSON.parse(event.data);
  
  // 处理客服消息推送
  if (message.type === 'push_message' && message.action === 'kefu_message') {
    console.log('收到消息:', message);
    // from_uid 表示发送者
    // to_uid 表示接收者（当前用户）
    // 更新消息列表
    // 更新未读消息数
    // 播放提示音等
  }
  
  // 处理会话结束推送
  if (message.type === 'push_message' && message.action === 'kefu_message_end') {
    console.log('会话已结束:', message);
    // from_uid 表示操作者
    // to_uid 数组包含所有接收者
    // 更新会话状态
    // 禁用发送消息功能
  }
};
```

---

## 游客对接

### 概述

游客对接适用于**未登录用户**的客服咨询场景。游客无需登录认证，使用 `visitor_id`（如 session_id 或设备ID）标识身份。

### 与用户端对接的区别

| 特性 | 用户端 | 游客端 |
|------|--------|--------|
| 认证方式 | 需要Token登录 | 无需认证 |
| 身份标识 | `user_id` | `visitor_id` |
| 会话管理 | 自动分配客服 | 需要指定 `kefu_id` |
| WebSocket连接 | 需要登录认证 | 无需登录，直接连接 |

### 快速开始

**基本流程**：
```
1. 生成游客标识（visitor_id）→ 如 session_id 或设备ID
2. 建立WebSocket连接 → 无需登录认证
3. 绑定连接（可选）→ 用于接收消息推送
4. 发送消息 → 通过WebSocket发送消息（需指定kefu_id）
5. 接收消息 → 监听WebSocket推送
6. 结束会话 → 通过WebSocket结束会话
```

### WebSocket连接

**建立连接**（无需登录）：
```javascript
const ws = new WebSocket('ws://your-domain/ws');

ws.onopen = () => {
  console.log('WebSocket连接成功');
  // 游客无需登录认证，可以直接发送消息
};
```

### 游客Action

#### 1. 绑定游客连接（用于消息推送）

**Action**: `kefu_message_visitor_bind_fd`

**功能说明**：
- 将当前WebSocket连接与 `visitor_id` 绑定
- 绑定后，客服发送的消息会推送到该连接
- 建议在建立连接后立即绑定

**请求格式**：
```json
{
  "action": "kefu_message_visitor_bind_fd",
  "data": {
    "bind_key": "visitor_123456"
  },
  "op_id": "unique_op_id"
}
```

**参数说明**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| bind_key | string | 是 | 游客标识（visitor_id），用于建立连接映射 |

**响应示例**：
```json
{
  "success": true,
  "message": "Bind key successfully",
  "data": null,
  "op_id": "unique_op_id"
}
```

#### 2. 游客发送消息

**Action**: `kefu_message_visitor_send`

**请求格式**：
```json
{
  "action": "kefu_message_visitor_send",
  "data": {
    "visitor_id": "visitor_123456",
    "kefu_id": "1",
    "content": "你好，我需要帮助"
  },
  "op_id": "unique_op_id"
}
```

**参数说明**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| visitor_id | string | 是 | 游客标识（session_id或设备ID） |
| kefu_id | string | 是 | 客服ID（必须指定） |
| content | string | 是 | 消息内容（文本消息） |

**重要说明**：
- `visitor_id` 和 `kefu_id` 都是**必填参数**
- `sender_type` 默认为 `1`（游客），**无需传入**
- **当前版本仅支持文本消息**（`message_type` 固定为 1，不支持图片和文件）
- 游客消息会推送给对应的客服（通过 `kefu_id` 找到客服的 `user_id`）

**响应示例**：
```json
{
  "success": true,
  "message": "Visitor message sent successfully",
  "data": {
    "message_id": 123
  },
  "op_id": "unique_op_id"
}
```

**错误响应**：
```json
{
  "success": false,
  "message": "visitor_id is required",
  "op_id": "unique_op_id"
}
```

#### 3. 结束游客会话

**Action**: `kefu_message_visitor_end`

**请求格式**：
```json
{
  "action": "kefu_message_visitor_end",
  "data": {
    "visitor_id": "visitor_123456",
    "kefu_id": "1"
  },
  "op_id": "unique_op_id"
}
```

**参数说明**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| visitor_id | string | 是 | 游客标识 |
| kefu_id | string | 是 | 客服ID |

**响应示例**：
```json
{
  "success": true,
  "message": "Visitor conversation ended successfully",
  "data": {},
  "op_id": "unique_op_id"
}
```

### 游客消息推送

当客服回复游客消息时，会推送以下格式的消息：

```json
{
  "type": "push_message",
  "action": "kefu_visitor_message",
  "visitor_id": "visitor_123456",
  "kefu_id": "1",
  "message_id": 123,
  "content": "您好，有什么可以帮您的吗？",
  "sender_type": 2,
  "created_at": "2025-01-01 10:00:00",
  "timestamp": 1704067200
}
```

**字段说明**：
- `type`: 固定为 `"push_message"`，用于标识这是推送消息
- `action`: 固定为 `"kefu_visitor_message"`，用于标识这是游客消息推送
- `visitor_id`: 游客标识
- `kefu_id`: 客服ID
- `message_id`: 消息ID
- `content`: 消息内容（文本消息）
- `sender_type`: 发送者类型，1-游客，2-客服
- `created_at`: 消息创建时间
- `timestamp`: 时间戳

**注意**：当前版本游客消息仅支持文本消息，推送消息中不包含 `message_type` 和 `file_url` 字段。

**接收推送消息示例**：
```javascript
ws.onmessage = (event) => {
  const message = JSON.parse(event.data);
  
  // 处理游客消息推送
  if (message.type === 'push_message' && message.action === 'kefu_visitor_message') {
    console.log('收到客服回复:', message);
    // visitor_id 表示这是发给哪个游客的消息
    // sender_type: 2 表示客服发送
    // 更新消息列表
    // 显示新消息
  }
  
  // 处理会话结束推送
  if (message.type === 'push_message' && message.action === 'kefu_visitor_conversation_end') {
    console.log('会话已结束:', message);
    // visitor_id: 游客标识
    // kefu_id: 客服ID
    // sender_type: 操作者类型
    // 更新会话状态
    // 禁用发送消息功能
  }
};
```

**游客会话结束推送格式**：

当游客会话被结束时，会推送以下格式的消息：

```json
{
  "type": "push_message",
  "action": "kefu_visitor_conversation_end",
  "visitor_id": "visitor_123456",
  "kefu_id": "1",
  "sender_type": 1,
  "timestamp": 1704067200
}
```

**字段说明**：
- `type`: 固定为 `"push_message"`，用于标识这是推送消息
- `action`: 固定为 `"kefu_visitor_conversation_end"`，用于标识这是游客会话结束推送
- `visitor_id`: 游客标识
- `kefu_id`: 客服ID
- `sender_type`: 操作者类型，1-游客，2-客服
- `timestamp`: Unix时间戳（秒）

### 游客完整集成示例

#### 1. 绑定游客连接

**请求格式**：
```json
{
  "action": "kefu_message_visitor_bind_fd",
  "data": {
    "bind_key": "visitor_123456"
  },
  "op_id": "unique_op_id"
}
```

**响应示例**：
```json
{
  "success": true,
  "message": "Bind key successfully",
  "data": null,
  "op_id": "unique_op_id"
}
```

#### 2. 游客发送消息

**请求格式**：
```json
{
  "action": "kefu_message_visitor_send",
  "data": {
    "visitor_id": "visitor_123456",
    "kefu_id": "1",
    "content": "你好，我需要帮助"
  },
  "op_id": "unique_op_id"
}
```

**响应示例**：
```json
{
  "success": true,
  "message": "Visitor message sent successfully",
  "data": {
    "message_id": 123
  },
  "op_id": "unique_op_id"
}
```

**错误响应**：
```json
{
  "success": false,
  "message": "visitor_id is required",
  "op_id": "unique_op_id"
}
```

#### 3. 结束游客会话

**请求格式**：
```json
{
  "action": "kefu_message_visitor_end",
  "data": {
    "visitor_id": "visitor_123456",
    "kefu_id": "1"
  },
  "op_id": "unique_op_id"
}
```

**响应示例**：
```json
{
  "success": true,
  "message": "Visitor conversation ended successfully",
  "data": {},
  "op_id": "unique_op_id"
}
```

#### 4. 接收消息推送

**消息推送格式**：
```json
{
  "type": "push_message",
  "action": "kefu_visitor_message",
  "visitor_id": "visitor_123456",
  "kefu_id": "1",
  "message_id": 123,
  "content": "您好，有什么可以帮您的吗？",
  "sender_type": 2,
  "created_at": "2025-01-01 10:00:00",
  "timestamp": 1704067200
}
```

#### 5. 接收会话结束推送

**会话结束推送格式**：
```json
{
  "type": "push_message",
  "action": "kefu_visitor_conversation_end",
  "visitor_id": "visitor_123456",
  "kefu_id": "1",
  "sender_type": 1,
  "timestamp": 1704067200
}
```

### 游客对接注意事项

1. **游客标识（visitor_id）**
   - 建议使用 `session_id` 或设备唯一标识
   - 同一游客应使用相同的 `visitor_id`，以便客服查看历史消息
   - 可以使用 `localStorage` 或 `sessionStorage` 保存 `visitor_id`

2. **客服ID（kefu_id）**
   - 游客发送消息时必须指定 `kefu_id`
   - 可以通过服务器API获取可用客服列表，让用户选择
   - 或者服务器自动分配客服后返回 `kefu_id`

3. **消息类型限制**
   - **当前版本仅支持文本消息**
   - 不支持图片消息（`message_type = 2`）和文件消息（`message_type = 3`）
   - 如需发送图片或文件，建议先上传到服务器获取URL，然后以文本形式发送URL

4. **连接绑定**
   - 建议在建立连接后立即调用 `kefu_message_visitor_bind_fd` 绑定连接
   - 绑定后，客服发送的消息会推送到该连接
   - 如果不绑定，只能通过轮询或其他方式获取消息

5. **消息推送**
   - 游客消息推送的 `action` 为 `"kefu_visitor_message"`
   - 通过 `visitor_id` 字段判断消息是否属于当前游客
   - 会话结束推送的 `action` 为 `"kefu_visitor_conversation_end"`
   - 推送逻辑：游客发送（sender_type=1）推送给客服，客服发送（sender_type=2）推送给游客

6. **无需认证**
   - 游客操作无需登录认证
   - WebSocket连接后可以直接发送消息
   - 所有游客相关的 action 都包含 `visitor` 关键字

---

## 完整集成示例

### 1. HTTP API接口

#### 获取或创建会话

**请求示例**：
```javascript
GET /api/kefu/message/getConversation
Headers: {
  'Authorization': 'Bearer your_user_token'
}
```

**响应示例**：
```json
{
  "code": 200,
  "data": {
    "id": 1,
    "kefu_id": 1,
    "user_id": 100,
    "status": 1,
    "last_message_at": null,
    "unread_count": 0,
    "kefu_unread_count": 0,
    "created_at": "2025-01-01 10:00:00",
    "updated_at": "2025-01-01 10:00:00"
  }
}
```

#### 获取消息列表

**请求示例**：
```javascript
GET /api/kefu/message/list?conversation_id=1&page=1&page_size=20
Headers: {
  'Authorization': 'Bearer your_user_token'
}
```

**响应示例**：
```json
{
  "code": 200,
  "data": [
    {
      "id": 1,
      "conversation_id": 1,
      "sender_id": 100,
      "sender_type": 1,
      "content": "你好",
      "message_type": 1,
      "file_url": null,
      "is_read": 0,
      "read_at": null,
      "created_at": "2025-01-01 10:00:00",
      "updated_at": "2025-01-01 10:00:00"
    },
    {
      "id": 2,
      "conversation_id": 1,
      "sender_id": 1,
      "sender_type": 2,
      "content": "您好，有什么可以帮您的吗？",
      "message_type": 1,
      "file_url": null,
      "is_read": 1,
      "read_at": "2025-01-01 10:05:00",
      "created_at": "2025-01-01 10:02:00",
      "updated_at": "2025-01-01 10:05:00"
    }
  ]
}
```

### 2. WebSocket接口

#### 发送消息

**请求格式**：
```json
{
  "action": "kefu_message_send",
  "data": {
    "conversation_id": 1,
    "content": "你好",
    "message_type": 1,
    "file_url": null
  },
  "op_id": "unique_op_id"
}
```

**响应示例**：
```json
{
  "success": true,
  "message": "Message sent successfully",
  "data": {
    "message_id": 123,
    "created_at": "2025-01-01 10:00:00"
  },
  "op_id": "unique_op_id"
}
```

**错误响应**：
```json
{
  "success": false,
  "message": "conversation_id is required",
  "op_id": "unique_op_id"
}
```

#### 标记消息已读

**请求格式**：
```json
{
  "action": "kefu_message_read",
  "data": {
    "conversation_id": 1,
    "message_ids": [1, 2, 3],
    "sender_type": 2
  },
  "op_id": "unique_op_id"
}
```

**响应示例**：
```json
{
  "success": true,
  "message": "Messages marked as read",
  "data": {
    "updated_count": 3
  },
  "op_id": "unique_op_id"
}
```

#### 结束会话

**请求格式**：
```json
{
  "action": "kefu_message_end",
  "data": {
    "conversation_id": 1
  },
  "op_id": "unique_op_id"
}
```

**响应示例**：
```json
{
  "success": true,
  "message": "Conversation ended successfully",
  "data": {
    "conversation_id": 1
  },
  "op_id": "unique_op_id"
}
```

**错误响应**：
```json
{
  "success": false,
  "message": "Failed to end conversation. Conversation not found or no permission.",
  "op_id": "unique_op_id"
}
```

### 3. 消息推送

#### 接收消息推送

**消息推送格式**：
```json
{
  "type": "push_message",
  "action": "kefu_message",
  "conversation_id": 1,
  "message_id": 123,
  "sender_id": 1,
  "sender_type": 2,
  "from_uid": 1,
  "to_uid": 100,
  "content": "您好，有什么可以帮您的吗？",
  "message_type": 1,
  "file_url": null,
  "created_at": "2025-01-01 10:00:00",
  "timestamp": 1704067200
}
```

#### 接收会话结束推送

**会话结束推送格式**：
```json
{
  "type": "push_message",
  "action": "kefu_message_end",
  "conversation_id": 1,
  "operator_id": 100,
  "operator_type": 1,
  "from_uid": 100,
  "to_uid": [100, 1],
  "timestamp": 1704067200
}
```

---

## 注意事项

### 1. WebSocket连接管理

- **连接保活**：建议实现心跳机制，定期发送 `ping` 消息保持连接
- **重连机制**：连接断开后应自动重连，并重新登录认证
- **多设备支持**：同一用户可以在多个设备上同时连接，消息会推送到所有设备

### 2. 会话管理

- **会话唯一性**：一个用户同一时间只能有一个进行中的会话（status=1）
- **自动分配**：首次调用 `getConversation` 时会自动分配客服
- **会话复用**：如果已有进行中的会话，会返回该会话，不会创建新会话

### 3. 消息处理

- **消息顺序**：推送消息按时间顺序到达，但网络延迟可能导致顺序不一致，建议按 `timestamp` 排序
- **消息去重**：通过 `message_id` 判断消息是否已存在，避免重复显示
- **已读状态**：标记已读后，会话的 `unread_count` 会自动清零

### 4. 权限验证

- **用户权限**：用户只能在自己的会话中发送消息和操作
- **会话验证**：所有操作都需要验证 `conversation_id` 是否属于当前用户

### 5. 错误处理

- **网络错误**：WebSocket连接失败时应提示用户检查网络
- **认证失败**：Token过期或无效时应引导用户重新登录
- **权限错误**：会话不存在或无权限时应提示用户重新获取会话

### 6. 性能优化

- **消息分页**：获取历史消息时使用分页，避免一次性加载过多消息
- **本地缓存**：已获取的消息可以缓存到本地，减少重复请求
- **延迟加载**：只在需要时加载历史消息，提升初始加载速度

### 7. 推送消息处理

- **消息推送**：`KefuMessageListener` 会自动推送消息，无需轮询
- **推送格式**：推送消息的 `action` 为 `"kefu_message"`，用于区分其他类型的消息
- **会话结束**：会话结束时推送 `action` 为 `"kefu_message_end"` 的消息（包含 `type: "push_message"`）
- **from_uid 和 to_uid**：用于标识消息的发送者和接收者，系统内部用于路由推送

---

## 版本信息

- **插件名称**: ds/kefu
- **版本**: 1.0.0
- **最后更新**: 2025-01-01

---

## 技术支持

如有问题或建议，请联系开发团队。
